spring.application.name=HealthConnect
server.port=8087

# --- BASE DE DATOS (NEON - DB: neondb) ---
# Usamos la nube para los datos, pero Eureka en local.
# spring.datasource.url=jdbc:postgresql://ep-floral-flower-ads55kyx-pooler.c-2.us-east-1.aws.neon.tech/neondb?sslmode=require
# spring.datasource.username=neondb_owner
# spring.datasource.password=npg_Ylivc96RCwna
# spring.datasource.driver-class-name=org.postgresql.Driver
#ENVIROMENT VARIABLES OF DATABASE
spring.datasource.url=${NEON_DB_URL}
spring.datasource.username=${NEON_DB_USERNAME}
spring.datasource.password=${NEON_DB_PASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# DDL: 'none' porque ya tienes el script SQL listo para correr manual.
spring.jpa.hibernate.ddl-auto=none
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# --- GRAPHQL ---
spring.graphql.graphiql.enabled=true
spring.graphql.path=/graphql

# --- SEGURIDAD JWT ---
# security.jwt.secret-key=8f2a9d6e5b8c1a7e4d9f6c8b3a5e7d4f9b8c2a6d8e0c1b7f4a9d6c8b3a5e7d4f
# security.jwt.expiration-time=3600000
#ENVIROMENT VARIABLES OF JWT
security.jwt.secret-key=${JWT_SECRET_KEY}
security.jwt.expiration-time=${JWT_EXPIRATION_TIME}

# --- EUREKA (Vuelta a LOCALHOST) ---
# Regresamos a la configuraci√≥n que te funcionaba
eureka.instance.prefer-ip-address=true
eureka.client.register-with-eureka=true
eureka.client.fetch-registry=true
eureka.client.service-url.defaultZone=http://localhost:8761/eureka
spring.cloud.compatibility-verifier.enabled=false


#ENVIROMENT VARIABLES
azure.ai.key=${AZURE_AI_KEY}
azure.ai.endpoint=${AZURE_AI_ENDPOINT}

azure.ai.language.key=${AZURE_AI_LANGUAGE_KEY}
azure.ai.language.endpoint=${AZURE_AI_LANGUAGE_ENDPOINT}
